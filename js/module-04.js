// // ПЕРЕБИРАЮЩИЕ МЕТОДЫ МАССИВОВ

// // ЗАНЯТИЕ 7. КОЛЛБЭКИ И СТРЕЛОЧНЫЕ ФУНКЦИИ

// Колбэк - функции


// Функции не отличаются от чисел, строк или массивов - это просто специальный тип данных(объект высшего порядка), значение, которое можно хранить в переменной или передавать как аргумент в другую функцию.

// function greet(name) {
//     return `Добро пожаловать ${name}.`;
// }

// // Вызываем функцию greet и выводим результат в консоль
// console.log(greet("Манго")); // Добро пожаловать Манго.

// // Выводим функцию greet в консоль не вызывая её
// console.log(greet); // ƒ greet() { return `Добро пожаловать ${name}.`; }
// В первом логе мы вызываем функцию greet при помощи круглых скобок и в консоль выводится результат её выполнения.Во втором логе передаётся ссылка на функцию, а не результат вызова(отсуствуют круглые скобки), поэтому в консоль выводится её тело.Это значит, что функцию можно присвоить в переменную или передать как аругмент другой функции.

// Функция обратного вызова(callback, колбэк) - это функция, которая передаётся другой функции в качестве аргумента и та, в свою очередь, вызывает переданную функцию.

// Функция высшего порядка(higher order function) - функция, принимающая в качестве параметров другие функции или возвращающая функцию как результат.

// // // Колбэк-функция
// function greet(name) {
//     console.log(`Добро пожаловать ${name}.`);
// }

// // // Функция высшего порядка
// function registerGuest(name, callback) {
//     console.log(`Регистрируем гостя ${name}.`);
//     callback(name);
// }

// registerGuest("Манго", greet); // Регистрируем гостя Манго. Добро пожаловать Манго.

// Мы передали ссылку на функцию greet как аргумент, поэтому она будет присвоена в параметр callback и вызвана внури функции registerGuest через круглые скобки.Имя параметра для колбэка может быть произвольным, главное помнить, что значением будет функция.


// Инлайн колбэки

// Если колбэк - функция маленькая и нужна только для передачи аргументом, её можно объявить прямо при вызове функции в которую передаём колбэк.Такая функция будет доступна только как значение параметра и больше нигде в коде.

// function registerGuest(name, callback) {
//     console.log(`Регистрируем гостя ${name}.`);
//     callback(name);
// }

// // // Передаём инлайн функцию greet как колбэк
// registerGuest("Манго", function greet(name) {
//     console.log(`Добро пожаловать ${name}.`);
// }); // Регистрируем гостя Манго. Добро пожаловать Манго.

// // Передаём инлайн функцию notify как колбэк
// registerGuest("Поли", function notify(name) {
//     console.log(`Уважаемый(ая) ${name}, ваш номер будет готов через 30 минут.`);
// }); // Регистрируем гостя Поли. Уважаемый(ая) Поли, ваш номер будет готов через 30 минут.


// Несколько колбэков

// Функция может принимать произвольное количество колбэков.Например, представим что мы пишем логику принятия звонков для телефона.Программа должна включить автоответчик если абонент недоступен, или соединить звонок в противном случае.Доступность абонента будем имитировать генератором случайного числа, чтобы между разными вызовами функции можно было получить различные результаты.

// function processCall(recipient) {
//     // Имитируем доступность абонента случайным числом
//     const isRecipientAvailable = Math.random() > 0.5;

//     if (!isRecipientAvailable) {
//         console.log(`Абонент ${recipient} недоступен, оставьте сообщение.`);
//         // Логика активации автоответчика
//     } else {
//         console.log(`Соединяем с ${recipient}, ожидайте...`);
//         // Логика принятия звонка
//     }
// }

// processCall("Манго");

// Проблема такого подхода в том, что функция processCall делает слишком много и привязывает проверку доступности абонента к двум заранее определённым действиям.Что если в будущем вместо автоответчика нужно будет оставлять голограмму ?

//     Мы могли бы написать функцию так, чтобы она возвращала какое - то значение и потом по результату её выполнения делать проверки и выполнять нужный код.Но проверки не относятся к внешнему коду и будут его засорять.

// Выполним рефакторинг функции так, чтобы она принимала два колбэка onAvailable и onNotAvailable, и вызывала их по условию.

// function processCall(recipient, onAvailable, onNotAvailable) {
//     // Имитируем доступность абонента случайным числом
//     const isRecipientAvailable = Math.random() > 0.5;

//     if (!isRecipientAvailable) {
//         onNotAvailable(recipient);
//         return;
//     }

//     onAvailable(recipient);
// }

// function takeCall(name) {
//     console.log(`Соединяем с ${name}, ожидайте...`);
//     // Логика принятия звонка
// }

// function activateAnsweringMachine(name) {
//     console.log(`Абонент ${name} недоступен, оставьте сообщение.`);
//     // Логика активации автоответчика
// }

// function leaveHoloMessage(name) {
//     console.log(`Абонент ${name} недоступен, записываем голограмму.`);
//     // Логика записи голограммы
// }

// processCall("Манго", takeCall, activateAnsweringMachine);
// processCall("Поли", takeCall, leaveHoloMessage);

// Колбэки применяются для обработки действий пользователя на странице, при обработке запросов на сервер, выполнения заранее неизвестных функций и т.п.В этом и заключается их суть - это функции предназначенные для отложенного выполнения.


// Абстрагирование повторения

// Абстракция - скрытие деталей реализации.Позволяет думать о задачах на более высоком(абстрактном) уровне.Функции это хороший способ построения абстракций.

//     Например, скрипт выполняет какое - то действие определенное количество раз.Для этого можно написать цикл for.

//         for(let i = 0; i < 10; i += 1) {
//     console.log(i);
// }
// Можем ли мы абстрагировать «делать что - то N раз» как функцию ? - да, напишем функцию, которая вызывает console.log() N раз.

// function repeatLog(n) {
//     for (let i = 0; i < n; i += 1) {
//         console.log(i);
//     }
// }

// repeatLog(5); // 0, 1, 2, 3, 4

// Но что, если мы хотим сделать что - то, кроме логирования чисел ? Поскольку «делать что - то» можно представить как функцию, а функции - это просто значения, мы можем передать действие как аргумент.

// function printValue(value) {
//     console.log(value);
// }

// function prettyPrint(value) {
//     console.log("Logging value: ", value);
// }

// function repeat(n, action) {
//     for (let i = 0; i < n; i += 1) {
//         action(i);
//     }
// }

// // Передаем printValue как callback-функцию
// repeat(3, printValue);
// // 0
// // 1
// // 2

// // Передаем prettyPrint как callback-функцию
// repeat(3, prettyPrint);
// // Logging value: 0
// // Logging value: 1
// // Logging value: 2


// Метод forEach

// Перебирающий метод массива который используется как замена циклов for и for...of при работе с коллекцией данных.

//     массив.forEach(function callback(element, index, array) {
//         // Тело коллбек-функции
//     });

// Поэлементно перебирает массив.
// Вызызвает коллбек - функцию для каждого элемента массива.
// Ничего не возвращает.

// Аргументы коллбек - функции это значение текущего элемента element, его индекс index и сам исходный массив array.Объявлять можно только те параметры которые нужны, чаще всего это элемент, главное не забывать про их порядок.

// const numbers = [5, 10, 15, 20, 25];

// // Классический for
// for (let i = 0; i < numbers.length; i += 1) {
//     console.log(`Индекс ${i}, значение ${numbers[i]}`);
// }

// // Перебирающий forEach
// numbers.forEach(function (number, index) {
//     console.log(`Индекс ${index}, значение ${number}`);
// });

// Единственным случаем, когда стоит использовать циклы for или for...of для перебора массива, это задачи с прерыванием выполнения цикла.Прервать выполнение метода forEach нельзя, он всегда перебирает массив до конца.


// Стрелочные функции

// Стрелочные функции имеют сокращённый, более лаконичный синтаксис, что уменьшает объем кода, особенно когда функция маленькая или если она используется как коллбек.

// Все стрелки создаются как функциональное выражение, и если функция не анонимна, то она должна быть присвоена переменной.

// // Обычное объявление функции
// function classicAdd(a, b, c) {
//     return a + b + c;
// }

// // Тоже самое как стрелочная функция
// const arrowAdd = (a, b, c) => {
//     return a + b + c;
// };

// Ключевое слово function не используется, вместо этого сразу идёт объявление параметров, за которыми следует символ => и тело функции.

// Если параметров несколько, то они перечисляются через запятую в круглых скобках, между знаками равно = и стрелкой =>.

// const add = (a, b, c) => {
//     return a + b + c;
// };
// Если параметр один, его объявление может быть без круглых скобок.

// const add = a => {
//     return a + 5;
// };
// Если параметров нет, то обязательно должны быть пустые круглые скобки.

// const greet = () => {
//     console.log("Привет!");
// };


// Неявный возврат

// В стрелочной функции после символа => идёт её тело.Здесь может быть два варианта: с фигурными скобками и без них.

// const add = (a, b, c) => {
//     console.log(a, b, c);
//     return a + b + c;
// };
// Если фигурные скобки есть, и функция должна возвращать какое - то значение, необходимо явно поставить return.Это называется явный возврат(explicit return). Такой синтаксис используется в том случае, если в теле функции нужно выполнить ещё какие - то инструкции кроме возврата значения.

// const add = (a, b, c) => a + b + c;
// Если фигурных скобок нет, то возвращается результат выражения стоящего после =>.Это называется неявный возврат(implicit return). В примере вернётся результат выражения сложения параметров a, b и c.

// Синтаксис неявного возврата сильно сокращает «шум» объявления функции с телом и возвращаемым выражением, но подходит только в случае когда в теле функции не нужно выполнять никаких дополнительных инструкций кроме возврата значения.

// // До
// function classicAdd(a, b, c) {
//     return a + b + c;
// }

// // После
// const arrowAdd = (a, b, c) => a + b + c;


// Псевдомассив arguments

// У стрелочных функций нет локальной переменной arguments, содержащей все аргументы.Если необходимо собрать все аргументы в массив, используется операция rest.

// const add = (...args) => {
//     console.log(args);
// };

// add(1, 2, 3); // [1, 2, 3]


// Стрелочные функции как коллбеки

// Анонимные стрелочные функции отлично подходят как коллбеки для перебирающих методов массива из - за более краткого синтаксиса объявления, особенно если не нужно тело функции.

// const numbers = [5, 10, 15, 20, 25];

// // Объявление функции
// numbers.forEach(function (number, index) {
//     console.log(`Индекс ${index}, значение ${number}`);
// });

// // Анонимная стрелочная функция
// numbers.forEach((number, index) => {
//     console.log(`Индекс ${index}, значение ${number}`);
// });

// Стрелочную коллбек - функцию также можно объявлять отдельно и передавать на неё ссылку.Это стоит делать если одна функция используется в нескольих местах программы или если она громоздкая.

// const numbers = [5, 10, 15, 20, 25];

// const logMessage = (number, index) => {
//     console.log(`Индекс ${index}, значение ${number}`);
// };

// numbers.forEach(logMessage);


// Разновидности кода


// Императивное программирование

// Описывает процесс вычисления в виде заданной последовательности инструкций, изменяющих состояние программы.Описание того, как что - то выполняется.

// Императивный стиль программирования - это такой, который дает машине набор детальных инструкций для выполнения задачи.Например цикл for, который предоставляет точные указания для итерации по индексам массива.

// Можно провести аналогию с рецептом приготовления блюда.Рецепт - это набор пошаговых инструкций для получения желаемого результата.


// Декларативное программирование

// Описывает то, что мы хотим получить в результате, а не как это сделать.Порядок выполнения и способ достижения не важен.

// Когда мы пишем HTML - код, то декларативно, при помощи тегов и атрибутов, описываем то, что хотим получить в результате.Браузер читает этот код и сам выполняет все необходимые операции по созданию HTML - элементов и помещению их на страницу.

// Можно провести аналогию с меню ресторана.Это декларативный набор возможных к заказу блюд, детали приготовления и подачи которых скрыты.

// food menu
// Декларативное описание задачи более наглядно и легче формулируется.Мы говорим, что хотим сделать, вызвав метод или функцию.Ее реализация, скорее всего использует императивный код, но он скрыт внутри и не усложняет понимание основного кода.

// Императивный vs декларативный

// Рассмотрим разницу подходов на примере базовой операции фильтрации коллекции.Напишем код перебора и фильтрации массива чисел по какому - то критерию.

// // Императивный подход
// const numbers = [1, 2, 3, 4, 5];
// const filteredNumbers = [];

// for (let i = 0; i < numbers.length; i += 1) {
//     if (numbers[i] > 3) {
//         filteredNumbers.push(numbers[i]);
//     }
// }

// console.log(filteredNumbers); // [4, 5]
// Метод filter() скрывает в себе логику перебора коллекции и вызывает callback - функцию, которую мы ему передаем для каждого элемента, возвращая массив элементов, подошедших под критерий.

// // Декларативный подход
// const numbers = [1, 2, 3, 4, 5];
// const filteredNumbers = numbers.filter(value => value > 3);
// console.log(filteredNumbers); // [4, 5]






// МОДУЛЬ 4. ЗАНЯТИЕ 8. ПЕРЕБИРАЮЩИЕ МЕТОДЫ МАССИВА


// Чистые функции

// Функция с побочными эффектами - это функция которая в процессе выполнения может изменять или использовать глобальные переменные, изменять значение аргументов ссылочного типа, выполнять операции ввода - вывода и т.п.

// const dirtyMultiply = (array, value) => {
//     for (let i = 0; i < array.length; i += 1) {
//         array[i] = array[i] * value;
//     }
// };

// const numbers = [1, 2, 3, 4, 5];
// dirtyMultiply(numbers, 2);
// // Произошла мутация исходных данных - массива numbers
// console.log(numbers); // [2, 4, 6, 8, 10]

// Функция dirtyMultiply(array, value) умножает каждый элемент массива array на число value.Она изменяет(мутирует) исходный массив по ссылке.


// Чистая функция(pure function) - это функция результат которой зависит только от значений переданных аргументов.При одинаковых аргументах она всегда возвращает один и тот же результат и не имеет побочных эффектов, то есть не изменяет значения аргументов.

// Напишем реализацию чистой функции умножения элементов массива, возвращающей новый массив, не изменяя исходный.

// const pureMultiply = (array, value) => {
//     const newArray = [];

//     array.forEach(element => {
//         newArray.push(element * value);
//     });

//     return newArray;
// };

// const numbers = [1, 2, 3, 4, 5];
// const doubledNumbers = pureMultiply(numbers, 2);

// // Не произошло мутации исходных данных
// console.log(numbers); // [1, 2, 3, 4, 5]
// // Функция вернула новый массив с изменёнными данными
// console.log(doubledNumbers); // [2, 4, 6, 8, 10]


// Перебирающие методы массива

// В JavaScript есть методы массивов пришедшие из функциональных языков.Большинство из них это чистые функции.Они создают новый массив, заполняют его, применяя к значению каждого элемента указанную коллбек - функцию, после чего возвращают этот новый массив.

// Все перебирающие методы массивов имеют схожий синтаксис.Исходный массив array, вызов метода method и callback - функция callback в качестве аргумента метода.

//     array.method(callback[currentValue, index, array])
// В большинстве методов, аргументами callback - функции являются значение элемента currentValue(первый параметр), позиция элемента index(второй параметр) и сам исходный массив array(третий параметр).

//     array.method((item, idx, arr) => {
//         // логика которая будет применяться на каждой итерации
//     });
// Все параметры, кроме значения элемента item, необязательны.Названия параметров могут быть любые, но есть неофициальные соглашения.

//     array.method(item => {
//         // логика которая будет применяться на каждой итерации
//     });


// Метод map()

// Метод map(callback) используется для трансформации массива.Он вызывает коллбек - функцию для каждого элемента исходного массива, а результат её работы записывает в новый массив, который и будет результатом выполнения метода.

//     массив.map((element, index, array) => {
//         // Тело коллбек-функции
//     });
// Поэлементно перебирает оригинальный массив.
// Не изменяет оригинальный массив.
// Результат работа коллбек - функции записывается в новый массив.
// Возвращает новый массив такой же длины.
// Его можно использовать для того, чтобы изменить каждый элемент массива.Оригинальный массив используется как эталон, на базе которого можно сделать другую коллекцию.

// const planets = ["Земля", "Марс", "Венера", "Юпитер"];

// const planetsInUpperCase = planets.map(planet => planet.toUpperCase());
// console.log(planetsInUpperCase); // ['ЗЕМЛЯ', 'МАРС', 'ВЕНЕРА', 'ЮПИТЕР']

// const planetsInLowerCase = planets.map(planet => planet.toLowerCase());
// console.log(planetsInLowerCase); // ['земля', 'марс', 'венера', 'юпитер']

// // Оригинальный массив не изменился
// console.log(planets); // ['Земля', 'Марс', 'Венера', 'Юпитер']

// Использование анонимных стрелочных функций с неявным возвратом сильно сокращает «шум» объявления коллбек - функции, делая код чище и проще для восприятия.


// Массив объектов

// Мы уже знаем что повседневная задача это манипуляция массивом объектов.Например, получить массив значений свойства из всех объектов.Есть массив студентов, а нужно получить отдельный массив их имён.

// const students = [
//     { name: "Манго", score: 83 },
//     { name: "Поли", score: 59 },
//     { name: "Аякс", score: 37 },
//     { name: "Киви", score: 94 },
//     { name: "Хьюстон", score: 64 },
// ];

// const names = students.map(student => student.name);
// console.log(names); // ['Манго', 'Поли', 'Аякс', 'Киви', 'Хьюстон']
// Используя метод map() можно перебрать массив объектов, и в коллбек - функции вернуть значение свойства каждого из них.


// Метод flatMap()

// Метод flatMap(callback) аналогичен методу map(), но применяется в случаях когда результат это многомерный массив который необходимо «разгладить».

// массив.flatMap((element, index, array) => {
//     // Тело коллбек-функции
// });
// В массиве students хранится список студентов со списком предметов которые посещает студент в свойстве courses.Несколько студентов могут посещать один и тот же предмет.Необходимо составить список всех предметов которые посещает эта группа студентов, пока даже повторяющихся.

// const students = [
//     { name: "Манго", courses: ["математика", "физика"] },
//     { name: "Поли", courses: ["информатика", "математика"] },
//     { name: "Киви", courses: ["физика", "биология"] },
// ];

// students.map(student => student.courses);
// // [['математика', 'физика'], ['информатика', 'математика'], ['физика', 'биология']]

// students.flatMap(student => student.courses);
// // ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];
// Он вызывает коллбек - функцию для каждого элемента исходного массива, а результат её работы записывает в новый массив.Отличие от map() в том, что новый массив «разглаживается» на глубину равную единице(одна вложенность).Этот разглаженный массив и есть результат работы flatMap().


// Метод filter()

// Метод filter(callback) используется для единственной операции - фильтрации массива, то есть когда необходимо выбрать более одного элемента из коллекции по какому - то критерию.

//     массив.filter((element, index, array) => {
//         // Тело коллбек-функции
//     });
// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает новый массив.
// Добавляет в возвращаемый массив элементы которые удовлетворяют условию коллбек - функции.
// Если коллбек вернул true элемент добавляется в возвращаемый массив.
// Если коллбек вернул false элемент не добавляется в возвращаемый массив.
// Если ни один элемент не удовлетворил условию, возвращает пустой массив.
// const values = [51, -3, 27, 21, -68, 42, -37];

// const positiveValues = values.filter(value => value >= 0);
// console.log(positiveValues); // [51, 27, 21, 42]

// const negativeValues = values.filter(value => value < 0);
// console.log(negativeValues); // [-3, -68, -37]

// const bigValues = values.filter(value => value > 1000);
// console.log(bigValues); // []

// // Оригинальный массив не изменился
// console.log(values); // [51, -3, 27, 21, -68, 42, -37]
// То есть метод filter вызывает коллбек - функцию для каждого элемента исходного массива и если результат её выполнения true, текущий элемент добавляет в новый массив.


// Фильтрация уникальных элементов

// Используя метод filter() можно выполнить фильтрацию массива так, что в нём останутся только уникальные элементы.Этот приём работает только с массивом примитивных значений - не объектов.

// Вернёмся к группе студентов и массиву всех посещаемых предметов, которые мы получили методом flatMap().

// const students = [
//     { name: "Манго", courses: ["математика", "физика"] },
//     { name: "Поли", courses: ["информатика", "математика"] },
//     { name: "Киви", courses: ["физика", "биология"] },
// ];

// const allCourses = students.flatMap(student => student.courses);
// console.log(allCourses);
// ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];
// // В переменной allCourses хранится массив всех посещаемых предметов, которые могут повторяться.Задача заключается в том, чтобы сделать новый массив, в котором будут только уникальные предметы, то есть без повторений.

// const uniqueCourses = allCourses.filter(
//     (course, index, array) => array.indexOf(course) === index
// );
// console.log(uniqueCourses);

// Используя array.indexOf(course) выполняем поиск первого совпадения текущего элемента course и получаем его индекс в оригинальном массиве всех курсов.В параметре index хранится индекс текущего элемента course при переборе массива методом filter.

// Если результат indexOf() и значение index равны - это уникальный элемент, потому что это первый раз когда такое значение встречается в массиве и на текущей итерации фильтр обрабатывает именно его.

// # Массив всех курсов
// ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];
// Для элемента 'математика' под индексом 0:

// indexOf() вернёт 0, потому что ищет первое совпадение.
// Значение параметра index будет 0.
// Они равны, значит это уникальный элемент.
// Для элемента 'математика' под индексом 3:

// indexOf() вернёт 0, потому что ищет первое совпадение.
// Значение параметра index будет 3.
// Они не равны, значит это повторяющийся - не уникальный элемент.
// Массив объектов
// При работе с массивом объектов выполняется фильтрация по значению какого - то свойства.В результате получается новый массив отфильтрованных объектов.

//     Например, есть массив студентов с баллами за тест.Необходимо отфильтровать лучших(балл выше 80), худших(балл ниже 50) и средних студентов(балл от 50 до 80).

// const LOW_SCORE = 50;
// const HIGH_SCORE = 80;
// const students = [
//     { name: "Манго", score: 83 },
//     { name: "Поли", score: 59 },
//     { name: "Аякс", score: 37 },
//     { name: "Киви", score: 94 },
//     { name: "Хьюстон", score: 64 },
// ];

// const best = students.filter(student => student.score >= HIGH_SCORE);
// console.log(best); // Массив объектов с именами Манго и Киви

// const worst = students.filter(student => student.score < LOW_SCORE);
// console.log(worst); // Массив с одним объектом Аякс

// // В коллбек-функции удобно деструктуризировать свойства объекта
// const average = students.filter(
//     ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE
// );
// console.log(average); // Массив объектов с именами Поли и Хьюстон


// Метод find()

// Если метод filter(cabllack) используется для поиска всех элементов удовлетворяющим условию, то метод find(callback) позволяет найти и вернуть первый подходящий элемент, после чего перебор массива прекращается.То есть он ищет до первого совпадения.

//     массив.find((element, index, array) => {
//         // Тело коллбек-функции
//     });
// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает первый элемент удовлетворяющий условию, то есть когда коллбек возвращает true.
// Если ни один элемент не подошёл, то есть для всех элементов коллбек вернул false, метод возвращает undefined.
// Метод find() используется для одной задачи - поиска элемента по уникальному значению свойства.Например, поиск пользователя по почте, автомобиля по серийному номеру, книги по названию и т.п.

// const colorPickerOptions = [
//     { label: "red", color: "#F44336" },
//     { label: "green", color: "#4CAF50" },
//     { label: "blue", color: "#2196F3" },
//     { label: "pink", color: "#E91E63" },
//     { label: "indigo", color: "#3F51B5" },
// ];

// console.log(colorPickerOptions.find(option => option.label === "blue"));; // { label: 'blue', color: '#2196F3' }
// console.log(colorPickerOptions.find(option => option.label === "pink")); // { label: 'pink', color: '#E91E63' }
// console.log(colorPickerOptions.find(option => option.label === "white"));; // undefined


// Метод findIndex()

// Метод findIndex(callback) это современная замена методу indexOf().Позволяет выполнять поиск по более сложным условиям чем просто равенство.Используется как для поиска в массиве примитивов, так и в массиве обьектов.

//     массив.findIndex((element, index, array) => {
//         // Тело коллбек-функции
//     });
// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает индекс первого элемента удовлетворяющего условию, то есть когда коллбек возвращает true.
// Если ни один элемент не подошёл, то есть для всех элементов коллбек вернул false, метод возвращает - 1.

// const colorPickerOptions = [
//     { label: "red", color: "#F44336" },
//     { label: "green", color: "#4CAF50" },
//     { label: "blue", color: "#2196F3" },
//     { label: "pink", color: "#E91E63" },
//     { label: "indigo", color: "#3F51B5" },
// ];

// console.log(colorPickerOptions.findIndex(option => option.label === "blue")); // 2
// console.log(colorPickerOptions.findIndex(option => option.label === "pink")); // 3
// console.log(colorPickerOptions.findIndex(option => option.label === "white")); // -1


// Методы every() и some()

// Метод every()

// Проверяет проходят ли все элементы массива тест предоставляемый коллбек - функцией.Возвращает true или false.

//     массив.every((element, index, array) => {
//         // Тело коллбек-функции
//     });
// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает true если все элементы массива удовлетворяют условию.
// Возвращает false если хотябы один элемент массив не удовлетворяет условию.
// Перебор массива прекращается если коллбек возвращает false.

// // Все элементы больше либо равны нулю? - да
// console.log([1, 2, 3, 4, 5].every(value => value >= 0)); // true

// // Все элементы больше либо равны нулю? - нет
// console.log([1, 2, 3, -10, 4, 5].every(value => value >= 0));; // false


// Метод some()

// Проверяет проходит ли хотя бы один элемент массива тест предоставляемый коллбек - функцией.Возвращает true или false.

//     массив.some((element, index, array) => {
//         // Тело коллбек-функции
//     });
// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает true если хотя бы один элемент массива удовлетворяет условию.
// Возвращает false если ни один элемент массив не удовлетворяет условию.
// Перебор массива прекращается если коллбек возвращает true.
// // Есть хотя бы один элемент больше либо равный нулю? - да
// console.log([1, 2, 3, 4, 5].some(value => value >= 0)); // true

// // Есть хотя бы один элемент больше либо равный нулю? - да
// console.log([-7, -20, 3, -10, -14].some(value => value >= 0)); // true

// // Есть хотя бы один элемент меньше нуля? - нет
// console.log([1, 2, 3, 4, 5].some(value => value < 0)); // false

// // Есть хотя бы один элемент меньше нуля? - да
// console.log([1, 2, 3, -10, 4, 5].some(value => value < 0)); // true


// Массив объектов

// При работе с массивом объектов проверяется значение какого - то их свойства Например, есть массив объектов фруктов, необходимо узнать все ли фрукты есть в наличии и есть ли в наличии хоть какие - то фрукты более 0 штук.

// const fruits = [
//     { name: "apples", amount: 100 },
//     { name: "bananas", amount: 0 },
//     { name: "grapes", amount: 50 },
// ];

// // // every вернет true только если всех фруктов будет больше чем 0 штук
// const allAvailable = fruits.every(fruit => fruit.amount > 0); // false
// console.log("все ли фрукты есть в наличии?", allAvailable);
// // // some вернет true если хотябы одного фрукта будет больше чем 0 штук
// const anyAvailable = fruits.some(fruits => fruits.amount > 0); // true
// console.log("есть ли в наличии хоть какие-то фрукты?", anyAvailable)


// Метод reduce()

// Метод reduce(callback, initialValue) используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата, как аккумулятор.Немного сложнее других в усвоении, но результат стоит того.

//     массив.reduce((previousValue, element, index, array) => {
//         // Тело коллбек-функции
//     }, initialValue);
// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает что угодно.
// Делает что угодно.
// Легче всего представить его работу на примере подсчёта суммы элементов массива.

// const total = [2, 7, 3, 14, 6].reduce((previousValue, number) => {
//     return previousValue + number;
// }, 0);

// console.log(total); // 32

// Первый параметр коллбек - функции(previousValue) это аккумулятор, то есть промежуточный результат.Значение которое вернёт коллбек - функция на текущей итерации, будет значением этого параметра на следующей.

// Вторым аргументом для reduce() можно передать необязательное начальное значение аккумулятора - параметр initialValue.

// # Вначале метод reduce() создаёт внутреннюю переменную - аккумулятор и
// # присваивает ей значение параметра initialValue или первого элемента
// # перебираемого массива, если initialValue не задан.
//     previousValue = 0

// # Далее коллбек - функция вызывается для каждого элемента массива.Текущее значение
// # параметра previousValue это то, что вернула коллбек - функция на прошлой итерации.
//     Итерация 1 -> previousValue = 0 -> number = 2 -> return 0 + 2 -> return 2
// Итерация 2 -> previousValue = 2 -> number = 7 -> return 2 + 7 -> return 9
// Итерация 3 -> previousValue = 9 -> number = 3 -> return 9 + 3 -> return 12
// Итерация 4 -> previousValue = 12 -> number = 14 -> return 12 + 14 -> return 26
// Итерация 5 -> previousValue = 26 -> number = 6 -> return 26 + 6 -> return 32

// # После того как весь массив перебран, метод reduce() возвращает значение аккумулятора.
//     Результат - 32
// То есть метод reduce() используется когда необходимо взять «много» и привести к «одному». В повседневных задачах его применение сводится к работе с числами.

// Массив объектов
// При работе с массивом объектов выполняется редуцирование по значению какого - то свойства.Например, есть массив студентов с баллами за тест.Необходимо получить средний бал.

// const students = [
//     { name: "Манго", score: 83 },
//     { name: "Поли", score: 59 },
//     { name: "Аякс", score: 37 },
//     { name: "Киви", score: 94 },
//     { name: "Хьюстон", score: 64 },
// ];

// // Название аккумулятора может быть произвольным, это просто параметр функции
// const totalScore = students.reduce((total, student) => {
//     return total + student.score;
// }, 0);

// const averageScore = totalScore / students.length;

// console.log(averageScore);


// Продвинутый reduce

// Допустим у нас есть следующая задача: из массива постов твиттера отдельного пользователя необходимо посчитать сумму всех лайков.Можно перебрать циклом for или forEach, каждое из этих решений потребует дополнительного кода.А можно использовать reduce.

// const tweets = [
//     { id: "000", likes: 5, tags: ["js", "nodejs"] },
//     { id: "001", likes: 2, tags: ["html", "css"] },
//     { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
//     { id: "003", likes: 8, tags: ["css", "react"] },
//     { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
// ];

// // // Пройдем по всем элементам коллекции и прибавим значения свойства likes
// // // к аккумулятору, начальное значение которого укажем 0.
// const likes = tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);

// console.log(likes); // 32

// // Наверное подсчет лайков не одиночная операция, поэтому напишем функцию
// // для подсчета лайков из коллекции
// const countLikes = tweets => {
//     return tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);
// };

// console.log(countLikes(tweets)); // 32
// Заметили свойство tags у каждого поста ? Продолжая тему reduce, мы соберем в массив все теги, которые встречаются в постах.

// const tweets = [
//     { id: "000", likes: 5, tags: ["js", "nodejs"] },
//     { id: "001", likes: 2, tags: ["html", "css"] },
//     { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
//     { id: "003", likes: 8, tags: ["css", "react"] },
//     { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
// ];

// // // Пройдем по всем элементам коллекции и добавим значения свойства tags
// // // к аккумулятору, начальное значение которого укажем пустым массивом [].
// // // На каждой итерации пушим в аккумулятор все элементы tweet.tags и возвращаем его.
// // const tags = tweets.reduce((allTags, tweet) => {
// //     allTags.push(...tweet.tags);

// //     return allTags;
// // }, []);

// // console.log(tags);

// // // Наверное сбор тегов не одиночная операция, поэтому напишем функцию
// // // для сбора тегов из коллекции

// const getTags = tweets =>
//     tweets.reduce((allTags, tweet) => {
//         allTags.push(...tweet.tags);

//         return allTags;
//     }, []);

// console.log(getTags(tweets));

// После того, как мы собрали все теги из постов, хорошо бы было посчитать количество уникальных тегов в массиве.И снова reduce тут как тут.

// const tweets = [
//     { id: "000", likes: 5, tags: ["js", "nodejs"] },
//     { id: "001", likes: 2, tags: ["html", "css"] },
//     { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
//     { id: "003", likes: 8, tags: ["css", "react"] },
//     { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
// ];

// const getTags = tweets =>
//     tweets.reduce((allTags, tweet) => {
//         allTags.push(...tweet.tags);

//         return allTags;
//     }, []);

// const tags = getTags(tweets);
// console.log(tags);

// // // Вынесем callback-функцию отдельно, а в reducе передадим ссылку на нее.
// // // Это стандартная практика если callback-функция довольно большая.

// // // Если в объекте-аккумуляторе acc нету своего свойства с ключем tag,
// // // то создаем его и записывает ему значение 0.
// // // В противном случае увеличиваем значение на 1.

// const getTagStats = (acc, tag) => {
//     if (!acc.hasOwnProperty(tag)) {
//         acc[tag] = 0;
//     }

//     acc[tag] += 1;

//     return acc;
// };

// // // Начальное значение аккумулятора это пустой объект {}
// const countTags = tags => tags.reduce(getTagStats, {});

// const tagCount = countTags(tags);
// console.log(tagCount);


// Метод sort()

// Метод sort() сортирует элементы массива, но в отличии от остальных перебирающих методов, он сортирует исходный массив.

// Сортирует и изменяет исходный массив.
// Возвращает изменённый массив, то есть ссылку на отсортированный исходный.
// По умолчанию сортирует по возрастанию.
// Сортировка происходит путём приведения значений к строке и сравнения порядковых номеров в таблице Unicode.
// Такой массив чисел будет отсортирован по возврастанию.

// const scores = [61, 19, 74, 35, 92, 56];
// scores.sort();
// console.log(scores); // [19, 35, 56, 61, 74, 92]
// Но, так как по умолчанию значения приводятся к строке, стандартная сортировка чисел работает необычно.Поэтому в следующем упражнении мы рассмотрим как задавать свой порядок сортировки.

// const scores = [27, 2, 41, 4, 7, 3, 75];
// scores.sort();
// console.log(scores); // [2, 27, 3, 4, 41, 7, 75]
// Массив строк сортируется по алфавиту.

// const students = ["Вика", "Андрей", "Олег", "Юля", "Борис", "Катя"];
// students.sort();
// console.log(students); // [ 'Андрей', 'Борис', 'Вика', 'Катя', 'Олег', 'Юля' ]
// При этом порядковый номер заглавных букв меньше чем у прописных.

// const letters = ["b", "B", "a", "A", "c", "C"];
// letters.sort();
// console.log(letters); // ['A', 'B', 'C', 'a', 'b', 'c']
// Из - за того, что сортируется исходный массив, нарушается принцип чистоты функций и нельзя удобно сделать несколько производных коллекций на базе исходной.Например, сделать коллекцию отсортированную по возрастанию, а другую по убыванию.Поэтому перед сортировкой делают полную копию исходного массива и сортируют уже её.

// const scores = [61, 19, 74, 35, 92, 56];
// const ascendingScores = [...scores].sort();

// console.log(scores); // [61, 19, 74, 35, 92, 56]
// console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]
// Свой порядок сортировки чисел
// Для указания своего порядка сортировки методу sort(compareFunction) нужно передать коллбек - функцию с двумя параметрами.Это функция сравнения(compare function), порядок сортировки зависит от её результата.Метод sort() будет вызывать её для произвольных двух элементов.

//     массив.sort((a, b) => {
//         // Тело коллбек-функции
//     });
// a - первый элемент для сравнения.
//     b - второй элемент для сравнения.
// Если вызов compareFunction(a, b) возвращает любое отрицательное значение, то есть a меньше b, сортировка поставит a перед b.Это сортировка по возрастанию.

// const scores = [61, 19, 74, 35, 92, 56];
// const ascendingScores = [...scores].sort((a, b) => a - b);
// console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]
// Если вызов compareFunction(a, b) возвращает любое положительное значение больше нуля, то есть b больше a, сортировка поставит b перед a.Это сортировка по убыванию.

// const scores = [61, 19, 74, 35, 92, 56];
// const descendingScores = [...scores].sort((a, b) => b - a);
// console.log(descendingScores); // [92, 74, 61, 56, 35, 19]
// Eсли вызов compareFunction(a, b) вернёт 0, сортировка оставит a и b неизменными по отношению друг к другу, но отсортирует их по отношению ко всем другим элементам.Но вообще не важно, что возвращать, если их взаимный порядок не имеет значения.


// Свой порядок сортировки строк

// Для сортировки строк в алфавитном порядке, по возрастанию или убыванию, используется метод строк localeCompare().

//     firstString.localeCompare(secondString)
// Он вызывается на строке которую нужно сравнить(firstString) с той, что передана ему как аргумент(secondString).

// "a".localeCompare("b"); // -1
// "b".localeCompare("a"); // 1
// "a".localeCompare("a"); // 0
// "b".localeCompare("b"); // 0

// Возвращает отрицательное значение если firstString должна быть перед secondString.
// Возвращает положительное значение больше нуля если firstString должна быть после secondString.
// Если строки одинаковы, возвращается ноль.
// Это удобно использовать при сортировке строк, так как метод sort() ожидает такие же значения от коллбек - функции.

// const students = ["Вика", "Андрей", "Олег", "Юля", "Борис", "Катя"];

// const inAlphabetOrder = [...students].sort((a, b) => a.localeCompare(b));
// console.log(inAlphabetOrder); // ['Андрей', 'Борис', 'Вика', 'Катя', 'Олег', 'Юля']

// const inReversedOrder = [...students].sort((a, b) => b.localeCompare(a));
// console.log(inReversedOrder); // ['Юля', 'Олег', 'Катя', 'Вика', 'Борис', 'Андрей']

// Сортировка объектов

// // При работе с массивом объектов сортировка выполняется по числовому или строчному значению какого - то свойства.Например, есть группа студентов с баллами за тест.Необходимо отсортировать массив объектов по возрастанию и убыванию количества баллов, и по имени студента.

// const students = [
//     { name: "Манго", score: 83 },
//     { name: "Поли", score: 59 },
//     { name: "Аякс", score: 37 },
//     { name: "Киви", score: 94 },
// ];

// Одновременно не консолить. Только по-одному

// const inAscendingScoreOrder = students.sort(
//     (firstStudent, secondStudent) => firstStudent.score - secondStudent.score
// );
// console.log(inAscendingScoreOrder);

// const inDescendingScoreOrder = students.sort(
//     (firstStudent, secondStudent) => secondStudent.score - firstStudent.score
// );
// console.log(inDescendingScoreOrder);

// const inAlphabeticalOrder = students.sort((firstStudent, secondStudent) =>
//     firstStudent.name.localeCompare(secondStudent.name));
// console.log(inAlphabeticalOrder);


// Цепочки методов

// Есть массив объектов с именами, баллами и посещаемыми предметами каждого студента.

// const students = [
//     { name: "Манго", score: 83, courses: ["математика", "физика"] },
//     { name: "Поли", score: 59, courses: ["информатика", "математика"] },
//     { name: "Аякс", score: 37, courses: ["физика", "биология"] },
//     { name: "Киви", score: 94, courses: ["литература", "информатика"] },
// ];
// // Необходимо получить массив их имён отсортированный по возрастанию баллов за тест.Для этого мы отсортируем копию массива методом sort(), после чего методом map() составим массив значений свойства name из сортированного массива.

// const sortedByAscendingScore = [...students].sort((a, b) => a.score - b.score);
// console.log("Отсортированные по баллам", sortedByAscendingScore);
// const names = sortedByAscendingScore.map(student => student.name);

// console.log("Имена по порядку, согласно баллам", names); // ['Аякс', 'Поли', 'Манго', 'Киви']
// console.log("Исходный массив не изменился", students);

// Проблема в том, что у нас появляются промежуточные переменные после каждой операции кроме финальной.Переменная sortedByAscendingScore лишняя и необходима только для хранения промежуточного результата.

// Избавиться от таких «мёртвых» переменных можно группируя вызовы методов в цепочки.Каждый следующий метод будет выполняться на результате работы предыдущего.

// const names = [...students]
//     .sort((a, b) => a.score - b.score)
//     .map(student => student.name);

// console.log(names); // ['Аякс', 'Поли', 'Манго', 'Киви']
// Делаем копию исходного массива перед сортировкой.
// На копии вызываем метод sort().
// К результату работы метода sort() применяем метод map().
// Переменной names присваивается результат работы метода map().
// Получим сортированный по алфавиту массив уникальных посещаемых предметов.

// const uniqueSortedCourses = students
//     .flatMap(student => student.courses)
//     .filter((course, index, array) => array.indexOf(course) === index)
//     .sort((a, b) => a.localeCompare(b));

// console.log(uniqueSortedCourses); // ['биология', 'информатика', 'литература', 'математика', 'физика']
// На исходном массиве вызываем flatMap() и делаем разглаженный массив всех курсов.
// К результату метода flatMap() применяем метод filter() для фильтрации уникальных элементов.
// На результате метода filter() вызываем sort().
// Переменной uniqueSortedCourses присваивается результат работы метода sort().
// Цепочка методов может быть произвольной длины, но обычно не более 2 - 3 операций.Во - первых, перебирающие методы используются для сравнительно простых операций над коллекцией.Во - вторых, вызов каждого последующего метода, это дополнительный перебор массива, что при достаточном количестве, может сказаться на производительности.