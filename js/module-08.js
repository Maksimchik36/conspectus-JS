//    Модуль 8 - Занятие 15 - Модульность кода


// Node.js

// Node.js - легкая и эффективная среда выполнения JavaScript. Позволяет писать высокопроизводительные серверные приложения и инструменты. Node.js построен на JavaScript-движке V8 и написан на C++.

// Изначально Node.js создавался как серверное окружение для приложений, но разработчики начали использовать его для создания инструментов, помогающих автоматизировать выполнение локальных задач. В итоге возникшая вокруг Node.js новая экосистема инструментов, привела к трансформации процесса фронтенд-разработки.


// Установка

// Чтобы установить последнюю стабильную версию, перейдите на официальную страницу, скачайте LTS-инсталлятор и следуйте указаниям. Есть установщики для всех популярных операционных систем - Windows, MacOS и Linux.

// ИНТЕРЕСНО
// Пользователям Windows необходимо выбрать чекбоксы для установки всех дополнительных инструментов кроме Chocolatey. Это установит Python и всевозможные вспомогательные утилиты и компиляторы.

// После установки в терминале будет доступна команда node. Для того чтобы убедиться, что установка прошла успешно, проверьте версию, запустив в консоли команду node с флагом version.

// node --version


// JavaScript вне браузера

// Node.js позволяет выполнять JavaScript-код вне браузера. Откройте любой терминал и выполните команду node, запустится REPL (read-eval-print loop) - интерактивная среда выполнения JS-кода. Выведем что-то в консоль.

// ИНТЕРЕСНО
// Для того чтобы выйти из REPL, нажмите комбинацию Ctrl + C на Windows и Control + C на MacOS.

// Теперь создадим папку node-tut, а в ней файл index.js с кодом, который мы писали в REPL. Для запуска нужно открыть терминал и перейти в папку node-tut в которой лежит index.js.

// // index.js
// const message = "NodeJS in amazing!";
// console.log(message);

// Теперь в консоли запускаем файл с помощью команды node index.js и получаем тот же результат - вывод строки непосредственно в терминале.

// В этом и заключается суть Node.js - возможность выполнять JavaScript вне браузера. Таким образом можно писать целые приложения, например бэкенд или утилиты не зависящие от браузера.


// Пакетный менеджер npm

// Чтобы использовать все богатство инструментов (или пакетов) Node.js нам нужна возможность устанавливать и управлять ими. Для этого создан NPM (node package manager) - пакетный менеджер Node.js. Он устанавливает нужные пакеты и предоставляет удобный интерфейс для работы с ними.

// NPM состоит из трех основных компонентов:

// 1. Сайт npmjs.com - используется для поиска и ознакомления с документацией пакетов.
// 2. Интерфейс командной строки (CLI) - запускается из терминала и предоставляет набор команд для работы с реестром и пакетами. Позволяет создавать скрипты для запуска в терминале.
// 3. Реестр пакетов (registry) - большая общедоступная база данных инструментов разработки (пакетов).

// Пакет (package) - небольшая JavaScript библиотека, решающая специфическую задачу. Пакеты пишут сами разработчики и делятся с сообществом. Такой подход упрощает жизнь, потому что не нужно изобретать колесо, все колеса уже давно лежат на полках реестра и готовы к использованию.

// ИНТЕРЕСНО
// Пакеты абстрагируют реализацию функционала, предоставляя разработчику удобный интерфейс. Это делает код чище, читабельнее и позволяет легче его поддерживать.


// Команды NPM

// Сразу перечислим основные команды и будем последовательно использовать и рассматривать в деталях.

// npm init - инициализирует npm в проекте и создает файл package.json
// npm install - устанавливает все зависимости перечисленные в package.json
// npm list --depth=0 - выведет в терминале список локально установленных пакетов с номерами их версий, без зависимостей
// npm install [package-name] - установит пакет локально в папку node_modules
// npm uninstall [package-name] - удалит пакет, установленный локально и обновит package.json
// npm start и npm test - запустит скрипт start или test, расположенный в package.json
// npm run [custom-script] - запустит кастомный скрипт, расположенный в package.json
// npm outdated - используется для поиска обновлений, обнаружит совместимые версии программно и выведет список доступных обновлений
// npm update - обновит все пакеты до максимально разрешенной версии


// Инициализация проекта

// Каждый проект начинается с создания файла package.json - он отслеживает зависимости, содержит служебную информацию, позволяет писать npm-скрипты и служит инструкцией при создании нового проекта на основе уже готовых настроек. Создать файл package.json можно npm-командой init, тем самым инициализировав проект в текущей папке.

// npm init

// Вам будет предложено ввести название проекта, версию, описание и т. д. Можно просто нажимать Enter до тех пор, пока не будет создан package.json и размещен в папке проекта. Чтобы не нажимать Enter, пропуская пустые поля, используется команда init с флагом --yes. Флаг - дополнительная настройка для команды.

// npm init --yes

// ИНТЕРЕСНО
// У каждого флага есть есть псевдоним - его сокращённая запись. Псевдоним флага --yes это -y, поэтому комманды npm init --yes и npm init -y делают одно и тоже.

// Будет создан package.json со значениями по умолчанию. Чтобы установить эти значения, в терминале последовательно выполните следующие команды, подставив свое имя и почту.

// npm config set init.author.name "YOUR_NAME"
// npm config set init.author.email "YOUR_EMAIL"

// Можно редактировать файл package.json вручную или выполнить npm init ещё раз. Если открыть package.json в редакторе, он будет выглядеть примерно так. Это всего лишь метаданные о проекте.

// // package.json
// {
//   "name": "node-tut",
//   "version": "1.0.0",
//   "main": "index.js",
//   "scripts": {
//     "test": "echo \"Error: no test specified\" && exit 1"
//   },
//   "author": "Alexander Repeta <mycoolemail@mail.com>",
//   "license": "ISC",
//   "keywords": [],
//   "description": ""
// }


// npm-скрипты

// Скрипты позволяют запускать на исполнение установленные пакеты. Используя npm-скрипты, можно создавать целые системы сборки проекта. Автоматизируем запуск index.js. Для этого в файле package.json в поле scripts добавим скрипт запуска start.

// //  package.json
// {
//   "scripts": {
//     "start": "node index.js"
//   }
// }
// Теперь мы можем запустить его в терминале командой npm start.

// ВНИМАНИЕ
// Если создать скрипт с любым другим именем, кроме start или test, он будет запускаться как npm run имя-скрипта - не забудьте run. Ознакомтесь с документацией - How npm handles the "scripts" field.


// Установка пакетов

// Одна из возможностей, которые предоставляет npm - установка пакетов, которые извлекаются из реестра и распаковываются в папку node_modules в корне проекта. После того как файл package.json создан, можно добавить зависимости в проект.

// Зависимостью называют npm-пакет, который используется при разработке. Это всевозможные утилиты и библиотеки. Установим библиотеку validator.js для валидации строк, например ввода пользователя в поля формы.

// npm install validator

// NPM загрузил validator и поместил его в node_modules - папку, в которой будут находиться все внешние зависимости.

// ВНИМАНИЕ
// Не добавляйте папку node_modules в систему контроля версий, у всех разработчиков она будет своя. Если вы используете Git, не забывайте добавить папку node_modules в файл .gitignore.

// Обратите внимание на созданный файл package-lock.json - это журнал снимков дерева зависимостей проекта. Он гарантирует, что команда разработчиков использует одни и те же версии зависимостей. NPM автоматически обновляет его при добавлении, удалении и обновлении пакетов.

// В package.json появилась новая зависимость в поле dependencies. Это означает, что validator версии 11.1.0 был установлен как зависимость и готов к работе. Пакеты постоянно обновляются, ваша версия может отличаться.

// //  package.json
// {
//   "dependencies": {
//     "validator": "^11.1.0"
//   }
// }

// Для того чтобы получить интерфейс пакета в Node.js-коде, необходимо вызвать функцию require("имя-модуля"), аргументом передав ей имя модуля без определения пути - это называется абсолютный импорт. Путь не нужен, так как по умолчанию поиск модуля будет происходить в папке node_modules. Результатом своего выполнения функция вернет интерфейс модуля - объект с методами или просто функцию, зависит от пакета.

// // index.js
// const validator = require("validator");

// const validateEmail = email => {
//   return validator.isEmail(email);
// };

// console.log(
//   "Is mango@mail.com a valid email?: ",
//   validateEmail("mango@mail.com")
// );

// console.log(
//   "Is Mangozedog.com a valid email?: ",
//   validateEmail("Mangozedog.com")
// );

// Выполнив в терминале npm start получим.

// Is mango@mail.com a valid email?: true
// Is Mangozedog.com a valid email?: false


// Удаление пакетов

// Предположим, что установленная в предыдущем примере версия validator вызывает проблемы с совместимостью. Мы можем удалить этот пакет и поставить более старую версию.

// npm uninstall validator


// Установка определенной версии пакета

// Теперь установим нужную версию validator. В команде установки номер версии указывается после символа @.

// npm install validator@1.0.0

// ИНТЕРЕСНО
// Установка пакетов определенный версии используется в коммерческих проектах для того, чтобы гарантировать работу кодовой базы и возможность долгосрочной поддержки. Вы можете устанавливать самые последние версии.


// Типы зависимостей

// Представьте торт, для его приготовления шефу нужны продукты, именно они войдут в состав торта. Но для приготовления понадобятся и инструменты вроде мисок, ложек, лопаток и т. п. А еще на кухне есть столы и печи, холодильники и т. д. - то, что используется для приготовления любого блюда, общие инструменты которые есть на кухне.

// То же самое и с зависимостями проекта - некоторые будут использованы в результирующем продукте, другие необходимы только на стадии разработки, а есть такие, что необходимо использовать вне зависимости от проекта.

// Именно для этого у команд npm install и npm uninstall есть три флага.

// --save - указывает, что добавляется зависимость, которая войдет в финальный продукт. Пакет будет установлен локально, в папку node_modules и будет добавлена запись в поле dependencies в package.json.
// --save-dev - указывает, что добавляется зависимость разработки. Пакет будет установлен локально, в папку node_modules, и будет добавлена запись в поле devDependencies в package.json.
// --global - указывает, что добавляется глобальная зависимость, то есть инструмент, который доступен для любого проекта. Пакет будет установлен глобально (в систему).

// ИНТЕРЕСНО
// Если не указывать флаг, по умолчанию будет использован --save.
// При удалении пакета необходимо указывать правильный флаг, такой же как при установке.
// Не устанавливайте пакеты глобально если вы работаете на проекте с другими разработчиками.


// Управление версиями пакетов

// Пакеты имеют связанный с ними номер версии. Номера версий соответствуют стандарту SemVer.

// npm outdated - используется для поиска обновлений, обнаружит совместимые версии программно.
// npm update - обновит все пакеты до максимально разрешенной версии.
// npm update [имя-пакета] - обновит указанный пакет.

// ИНТЕРЕСНО
// Если вы не доверяете машинам или хотите какую-то определённую версию пакета, можно открыть package.json и вручную поменять версии пакетов, после чего выполнить npm install.


// Управление кэшем

// После установки пакета npm сохраняет его копию в кэше, поэтому при следующей его установке вам не нужно опять скачивать его из интернета. Кэш хранится в папке .npm вашего домашнего каталога.

// Эта папка со временем засоряется старыми пакетами и иногда ее полезно очищать, не слишком часто (пару раз в год), кеширование полезно, так как сокращает время установки уже использованных пакетов.

// npm cache clean



// Модульность кода


// Концепция модулей как способа организации кода существовала давно. С ростом проекта и его кодовой базы ее пытаются разбить на файлы, в каждом из которых описывается отдельный функционал.

// Модульный код помогает в организации, обслуживании, тестировании и, самое главное, управлении зависимостями. Наиболее важные преимущества модулей - это поддерживаемость, пространство имен и повторное использование.

// Поддерживаемость - хорошо разработанный модуль призван максимально снизить зависимость от других частей кода. Это позволит расширять функционал приложения не опасаясь нарушить его работу в целом. Обновление одного модуля намного проще, если модуль самодостаточен.

// Пространство имен - переменные, не входящие в область видимости функции, являются глобальными. Из-за этого обычно происходит загрязнение пространства имен, где полностью несвязанный код разделяет глобальные переменные. Модули позволяют избежать загрязнения пространства имен, создавая отдельную область видимости для переменных.

// Повторное использование - все разработчики копировали готовый код в новые проекты, изменяя его под специфику проекта. Это, очевидно, огромная трата времени. Намного лучше когда есть модуль, который можно повторно использовать снова и снова без необходимости знать что-либо об окружении в котором он используется.


// Сборка модулей

// Сборка модулей - это процесс конкатенации группы модулей и их зависимостей в один или группу файлов.

// Обычно код делят на папки и файлы, к тому же необходимо подключить внешние библиотеки. В результате каждый из этих файлов должен быть включен в основной HTML-файл в теге <script>, который затем загружается браузером.

// Наличие отдельных тегов <script> для каждого файла означает, что браузер будет загружать каждый файл по отдельности, что негативно сказывается на скорости загрузки страницы. Чтобы обойти эту проблему, файлы объединяются в один или пару файлов, чтобы уменьшить количество запросов. Но остается проблема управления зависимостями между модулями.

// Если используются системы модулей, такие как CommonJS или ESM, необходимо использовать инструмент для их преобразования в правильно упорядоченный, доступный браузеру код. Именно здесь вступают в действие Webpack и другие бандлеры (от английского bundle).


// ECMAScript Modules (ESM)

// До недавнего времени в языке не было встроенной модульной системы. ESM имеют компактный декларативный синтаксис и возможность асинхронной загрузки. ES-модуль - это многократно используемый фрагмент JS-кода, который экспортирует определенные объекты, делая их доступными для других модулей.

// // greeter.js
// const helloMessage = "hello!";
// const goodbyeMessage = "goodbye!";

// export const hello = () => helloMessage;
// export const goodbye = () => goodbyeMessage;


// // index.js
// import { hello, goodbye } from "./greeter";

// console.log(hello()); // "hello!"
// console.log(goodbye()); // "goodbye!"

// Каждый JS-файл хранит код в уникальном контексте модуля и импортирует необходимые ему зависимости и экспортирует все, что должно быть импортировано другими модулями. Операции экспорта/импорта реализованы конструкциями import и export. Есть два очевидных преимущества этого подхода - предотвращение загрязнения глобального пространства имен и явное указание зависимостей.

// Новая система модулей отличается от CommonJS и других, прежде всего тем, что это стандарт. А значит, со временем, будет полностью поддерживаться браузерами нативно, без дополнительных инструментов. Однако сейчас браузерная поддержка не полная, поэтому ESM используются в сочетании с инструментами сборки модулей, такими как Webpack, Parcel и другими.

// ИНТЕРЕСНО
// ESM разработаны с учетом статического анализа. Это значит, что при импорте модулей, импорт обрабатывается во время компиляции, то есть до запуска скрипта. Это позволяет удалять экспорт, который не используется другими модулями, прежде чем запускать скрипт, что может привести к значительной экономии веса JS-файла, уменьшив нагрузку на браузер. Это называется tree shaking и выполняется бандлерами автоматически при сборке JS кода.


// Named export

// Модуль может экспортировать несколько сущностей, которые отличаются своими именами и называются именованными экспортами. Чтобы импортировать их в другой модуль, необходимо знать имена экспортируемых сущностей, которые мы хотим импортировать.

// Первый способ - это использовать ключевое слово export перед всеми сущностями, которые необходимо экспортировать. Они будут добавлены как свойства в экспортируемый объект. При импорте мы деструктуризируем свойства из импортируемого объекта.

// //  my-module.js
// const sqrt = Math.sqrt;
// export const square = x => x * x;
// export const diag = (x, y) => sqrt(square(x) + square(y));


// // main.js
// import { square, diag } from "./path/to/my-module";

// console.log(square(11)); // 121
// console.log(diag(4, 3)); // 5

// Второй способ - это явно указать объект со свойствами для экспорта.

// // my-module.js
// const sqrt = Math.sqrt;
// const square = x => x * x;
// const diag = (x, y) => sqrt(square(x) + square(y));

// export { square, diag };


// // main.js
// import { square, diag } from "./path/to/myModule";

// console.log(square(11)); // 121
// console.log(diag(4, 3)); // 5

// Следующий синтаксис импортирует все экспорты модуля как объект с указанным именем. Это называется namespace import.

// // main.js
// import * as myModule from "./path/to/my-module";

// console.log(myModule.square(11)); // 121
// console.log(myModule.diag(4, 3)); // 5


// Default export

// Часто модуль экспортирует всего одну сущность, такой экспорт удобен для импорта. Экспорт по умолчанию - самое главное экспортируемое значение, которое может быть чем угодно: переменной, функцией, классом и т. д.

// // my-func.js
// export default function myFunc() {
//   // ...
// }

// // my-class.js
// export default class MyClass {
//   // ...
// }

// // main.js
// import myFunc from "./path/to/my-func";
// import MyClass from "./path/to/my-class";

// myFunc();

// const inst = new MyClass();

// Используйте именованный экспорт, когда необходимо экспортировать несколько сущностей, а экспорт по умолчанию - при экспорте одной сущности. Хотя и можно использовать экспорт по умолчанию и именованный экспорт в одном файле, хорошей практикой будет выбрать только один стиль для каждого модуля.



// Знакомство с Webpack

// Webpack - это сборщик JS-модулей, менеджер модульных зависимостей, который анализирует дерево зависимостей и создает один или несколько результирующих файлов, содержащих всю кодовую базу проекта. Выстраивает порядок подключения модулей, собирает, минифицирует, запаковывает и многое другое.

// Webpack стал одним из самых важных инструментов веб-разработчика. В первую очередь - это менеджер модульных зависимостей приложения и сборщик JS-файлов, но он может трансформировать все ресурсы (HTML и CSS, SASS и т. п.), оптимизировать изображения, компилировать шаблоны, запускать локальный веб-сервер для разработки и многое другое.


// Принцип работы

// Предположим, у нас есть приложение, которое может выполнять две простые математические задачи: суммировать и умножать. Мы решили разделить эти функции на отдельные файлы (модули) для упрощения поддержки кодовой базы. Тогда в index.html скрипты будут подключены в такой последовательности.

// // index.html
// <script src="sum.js"></script>
// <script src="multiply.js"></script>
// <script src="index.js"></script>

// Допустим код из sum.js используется в multiply.js и index.js, а код из multiply.js используется только в index.js. Покажем иерархию зависимостей на простой диаграмме.

// Если ошибиться в последовательности подключения скриптов в index.html, то есть если index.js подлючен перед любой из других зависимостей или если sum.js добавлен после multiply.js - будут ошибки. Теперь представим, что мы масштабируем это до реального, полностью рабочего приложения - могут быть сотни зависимостей. Сохранение порядка подключения станет кошмаром.

// Webpack преобразует зависимости в модули и сошьет в один или несколько файлов. Каждый модуль будет иметь закрытое пространство имен и подключаться в нужное время, в правильном порядке.

// Gulp все еще занимает достойное место в инструментарии разработчика и для некоторых проектов, функционал Webpack не нужен, хотя он может отлично работать в связке с ним. Несмотря на то, что кривая обучения может быть выше при более сложных настройках, Webpack незаменим если вы используете современные библиотеки и фреймворки для разработки, такие как React, Vue, Angular и т. д.

// Настройка
// По ссылкам ниже вы найдете исчерпывающие руководства с пошаговыми объяснениями настройки Webpack.

// How to set up webpack 5 from scratch https://www.taniarascia.com/how-to-use-webpack/
// Документация Webpack https://webpack.js.org/concepts/




//    Модуль 8 - Занятие 16 - Веб-хранилище

// Формат JSON

// JSON (JavaScript Object Notation) - современный текстовый формат хранения и передачи структурированных данных в текстовом виде. Привычный объектоподобный синтаксис JSON очень удобен. Именно в этом формате данные будут приходить и отправляться на сервер, сохраняться в локальном хранилище и т. п.

// Но JSON - это не объект, а его строковое представление. Ниже приведен пример JSON файла. Синтаксис похож на объект, за исключением того, что ключи это всегда строки в двойных кавычках. Строчные значения также обязательно должны быть заключены в двойные кавычки. Значениями свойств могут быть типы string, number, object, array, boolean и null.

// //  user.json
// {
//   "name": "Josh",
//   "weight": 175,
//   "age": 30,
//   "eyecolor": "brown",
//   "isHappy": true,
//   "cars": ["Chevy", "Honda"],
//   "favoriteBook": {
//     "title": "The Last Kingdom",
//     "author": "Bernard Cornwell",
//     "rating": 8.38
//   }
// }

// Javascript и JSON отлично работают вместе благодаря методам встроенного класса JSON, которые преобразуют JavaScript объект в JSON и обратно. Независимо от того, что у вас есть, можно легко получить обратное.


// Метод JSON.stringify()

// Принимает значение и преобразовывает его в JSON. Значением может быть число, буль, null, массив или обьект. Строки это уже валидный JSON поэтому их преобразование не имеет смысла.

// const dog = {
//   name: "Mango",
//   age: 3,
//   isHappy: true,
// };

// const dogJSON = JSON.stringify(dog);
// console.log(dogJSON); // "{"name":"Mango","age":3,"isHappy":true}"

// Результат вызова JSON.stringify(dog) это валидный JSON (строка), который может быть сохранен в файл или передан по сети.

// Не любой JavaScript объект может быть преобразован один к одному в JSON. Например, если у объекта есть методы, то при преобразовании они будут проигнорированы.

// const dog = {
//   name: "Mango",
//   age: 3,
//   isHappy: true,
//   bark() {
//     console.log("Woof!");
//   },
// };

// const dogJSON = JSON.stringify(dog);
// console.log(dogJSON); // "{"name":"Mango","age":3,"isHappy":true}"

// Также при попытке преобразовать функцию в JSON, результатом будет undefined.

// JSON.stringify(() => console.log("Well, this is awkward")); // undefined


// Метод JSON.parse()

// Чтобы получить из JSON валидное JavaScript значение, его необходимо распарсить (parse). Это операция обратная преобразованию в строку (stringify). Теперь, когда dog это валидный объект, с ним можно работать как обычно.

// const json = '{"name":"Mango","age":3,"isHappy":true}';

// const dog = JSON.parse(json);
// console.log(dog); // {name: "Mango", age: 3, isHappy: true}
// console.log(dog.name); // "Mango"


// Обработка ошибок

// Если методам класса JSON передать невалидный JSON, то они «выбросят» ошибку и весь скрипт упадёт. Для того чтобы избежать этого, используется конструкция try...catch, которая позволяет «ловить» и обрабатывать ошибки выполнения скрипта.

// try {
//   // Code that may throw a runtime error
// } catch (error) {
//   // Error handling
// }

// 1. Сначала выполняется код внутри блока try.
// 2. Если ошибок нет, блок catch игнорируется и управление передаётся дальше.
// 3. Если в блоке try произошла ошибка, его выполнение останавливается и интерпретатор переходит в блок catch.

// Переменная error это объект ошибки с информацией о том, что произошло. У этого объекта есть несколько полезных свойств:

// 1. name - тип ошибки. Для ошибки парса это SyntaxError.
// 2. message - сообщение о деталях ошибки.
// 3. stack - стек вызовов функций на момент ошибки. Используется для отладки.

// Например, парс строки приведет к такому сценарию, потому что строка с символами это не валидный JSON, так как не может быть преобразована к валидному JavaScript значению.

// // Script will crash during parse
// const data = JSON.parse("Well, this is awkward");
// console.log("❌ You won't see this log");

// Используя конструкцию try...catch мы можем обработать это исключение так, чтобы скрипт продолжил работать даже в случае ошибки.

// try {
//   const data = JSON.parse("Well, this is awkward");
// } catch (error) {
//   console.log(error.name); // "SyntaxError"
//   console.log(error.message); // Unexpected token W in JSON at position 0
// }

// console.log("✅ This is fine, we handled parse error in try...catch");

// Тоже самое будет при попытке парса невалидного JSON, который, например, может прийти от бэкенда или быть прочитан из файла. В примере у свойства username не хватает обрамляющих двойных кавычек.

// try {
//   const data = JSON.parse('{username: "Mango"}');
// } catch (error) {
//   console.log(error.name); // "SyntaxError"
//   console.log(error.message); // "Unexpected token u in JSON at position 1"
// }

// console.log("✅ This is fine, we handled parse error in try...catch");


// Фазы выполнения кода

// В в JavaScript код исполняется не сразу, для начала движку нужно прочитать код и узнать можно ли его вообще выполнить.

// Фаза интерпретации или оценки (compile time, evaluation time) - подготовка перед исполнением кода, движок находит синтаксические ошибки, ошибки типизации и т. д. То есть код еще не выполняется, только оценивается. Если эта фаза прошла успешно, это как минимум значит, что в коде нет синтаксических ошибок и его можно запустить на исполнение.

// Фаза исполнения (runtime) - скрипт начинает исполняться, выполняются инструкции вызовов функций и оценки выражений, происходит поиск необходимых идентификаторов в соответствующих областях видимости и тому подобное.

// Если эта фаза завершилась успешно, значит скрипт написан без явных ошибок и закончил свою работу. На этой фазе могут быть ошибки, связанные с отсутствующими свойствами и переменными, преобразованием типов и т. д., то есть что-то, что происходит только во время выполнения кода.

// Попробуйте выполнить следующий код. Так как мы сделали опечатку и вместо const пытаемся объявить переменную value ключевым словом cos, на фазе компиляции будет выявлена синтаксическая ошибка и фаза исполнения даже не запустится. В консоли мы сразу увидим сообщение об ошибке.

// console.log('This message will not appear in the console');

// cos value = 5;

// ИНТЕРЕСНО
// try...catch ловит только ошибки которые произошли во время выполнения кода (runtime errors). Это значит, что код должен быть синтаксически правильным, иначе фаза выполнения просто не запустится. Ошибки, которые возникают во время фазы оценки, называются ошибками парсинга.



// Веб-хранилище

// Каждый раз когда вы изменяете цветовую тему между светлой и темной, просматриваете видео, добавляете товар в корзину, открываете или закрываете сайдбар, популярные веб-приложения запоминают состояние интерфейса и при следующем посещении его восстанавливают.

// По умолчанию состояние интерфейса хранится в памяти вкладки браузера и теряется при закрытии веб-приложения. Чтобы избежать этого, необходимо где-то сохранить данные о состоянии интерфейса между посещениями страницы. На помощь приходит хранение информации о состоянии веб-приложения на компьютере пользователя.


// Web Storage API

// Веб-хранилище состоит из локального хранилища (localStorage) и хранилища сеансов (sessionStorage). Предоставляет способ хранения данных интуитивно понятным способом в виде пар ключ:значение. Технически в веб-хранилище можно записать только строки, но это не проблема если использовать методы класса JSON для преобразования сложных типов. В веб-хранилище не записывают методы объектов или функции, только данные.

// Локальное хранилище (localStorage) уникально для каждого веб-приложения и будет одинаковым между несколькими вкладками в которых оно (веб-приложение) запущено. Данные в локальном хранилище не удаляются даже при закрытии браузера или выключении компьютера. Чтобы их удалить, необходимо использовать JavaScript.

// Хранилище сеансов (sessionStorage) похоже на локальное, оно также уникально для кажого веб-приложения, но время жизни сохраненных данных огрничено сессией вкладки браузера. Как только пользователь закрывает вкладку или браузер, данные очищаются. На практике хранилище сеансов используется значительно реже.

// ИНТЕРЕСНО
// В веб-хранилище не хранят пароли, номера банковских карт и тому подбную конфиденциальную информацию. Если вредоносный скрипт получит доступ к веб-странице, то без проблем прочитает эти данные.


// Локальное хранилище


// Позволяет хранить данные без истечения срока действия в формате пар ключ:значение на компьютере пользователя и читать их при повторном посещении страницы. Локальное и хранилище сессии это часть браузера, поэтому они доступны как свойства объекта window, имеют одинаковый набор свойств и методов и различаются только поведением.

// setItem(key, value) - делает новую, или обновляет уже существующую запись в хранилище.
// getItem(key) - возвращает из хранилища значение с ключом key.
// removeItem(key) - удаляет из хранилища запись с ключом key.
// clear() - полностью очищает все записи в хранилище.
// length - хранит количество записей в хранилище.


// Сохранение

// Используя метод setItem(key, value) можно добавить новую запись в виде пары ключ:значение.

// localStorage.setItem("ui-theme", "light");
// localStorage.setItem("sidebar", "expanded");
// localStorage.setItem("notification-level", "mute");

// Если необходимо сохранить что-то кроме строки, например массив или объект, необходимо преобразовать их в строку методом JSON.stringify().

// const settings = {
//   theme: "dark",
//   isAuthenticated: true,
//   options: [1, 2, 3],
// };

// localStorage.setItem("settings", JSON.stringify(settings));


// Чтение

// Метод getItem(key) позволяет прочитать из хранилища запись с ключом key. Если в хранилище нет записи с таким ключом, метод возвращает null. Когда значение это обычная строка - нет необходимости её парсить.

// localStorage.setItem("ui-theme", "dark");

// const theme = localStorage.getItem("ui-theme");
// console.log(theme); // "dark"

// В противном случае, необходимо распарсить значение методом JSON.parse(), чтобы получить валидные данные.

// const settings = {
//   theme: "dark",
//   isAuthenticated: true,
//   options: [1, 2, 3],
// };

// localStorage.setItem("settings", JSON.stringify(settings));

// const savedSettings = localStorage.getItem("settings");
// const parsedSettings = JSON.parse(savedSettings);
// console.log(parsedSettings); // settings object

// ИНТЕРЕСНО
// Не забывайте использовать конструкцию try...catch с методом JSON.parse(), чтобы избежать «падения» скрипта если вдруг прочитали не валидный JSON.


// Удаление

// Метод removeItem(key) удаляет из хранилища уже существующую запись с ключом key.

// localStorage.setItem("ui-theme", "light");
// console.log(localStorage.getItem("ui-theme")); // "dark"

// localStorage.removeItem("ui-theme");
// console.log(localStorage.getItem("ui-theme")); // null


// Очистка хранилища

// Операция полной очистки хранилища занятие опасное, так как может затронуть записи сделанные другими разработчиками проекта. Тем не менее, если вы хотите полностью очистить хранилище, вызовите метод clear().

// localStorage.setItem("ui-theme", "light");
// localStorage.setItem("sidebar", "expanded");
// localStorage.setItem("notification-level", "mute");
// console.log(localStorage.getItem("ui-theme")); // "light"
// console.log(localStorage.getItem("sidebar")); // "expanded"
// console.log(localStorage.getItem("notification-level")); // "mute"

// localStorage.clear();
// console.log(localStorage.getItem("ui-theme")); // null
// console.log(localStorage.getItem("sidebar")); // null
// console.log(localStorage.getItem("notification-level")); // null


// Сохраняем сообщение

// Создадим форму для ввода сообщения и будем сохранять его в localStorage при сабмите. Изменяйте значение текстового поля и нажимате кнопку «Save». Текст в поле вывода изменится на введенный. Перезагрузите страницу, и вы увидите все тот же текст, хотя ничего еще не вводили. При загрузке страницы мы берем из localStorage последнее сохраненное значение. Изначально такой записи в хранилище нет, поэтому будет выведена пустая строка.

// // Добавить во вкладку HTML 
// <p>Value from localStorage: <span id="output"></span></p>
// <form id="message-form">
//   <input type="text" class="input" name="message">
//   <button type="submit" class="btn">Save</button>
// </form>

// // Добавить во вкладку CSS
// body {
//     padding: 16px;
//   }
  
//   p {
//     margin-bottom: 0;
//   }

// // Добавить во вкладку JS
// const form = document.querySelector("#message-form");
// const output = document.querySelector("#output");
// const LOCALSTORAGE_KEY = "goit-example-message";

// updateOutput();
// form.addEventListener("submit", saveMessage);

// function saveMessage(evt) {
//   evt.preventDefault();
//   localStorage.setItem(LOCALSTORAGE_KEY, form.elements.message.value);
//   updateOutput();
//   form.reset();
// }

// function updateOutput() {
//   output.textContent = localStorage.getItem(LOCALSTORAGE_KEY) || "";
// }

// Посмотреть содержимое веб-хранилища можно в инструментах разработчика на вкладке Application. Там же можно вручную удалять и добавлять записи. На практике это используется во время разработки и отладки работы приложения.


// Сервис для localStorage

// Для того чтобы сократить количество повторяющегося кода при работе с веб-хранилищем, можно написать сервис с стандартными методами, например save и load. Они будут абстрагировать повторяющийся код проверки ошибок парса и тому подобную рутину.

// // storage.js
// const save = (key, value) => {
//   try {
//     const serializedState = JSON.stringify(value);
//     localStorage.setItem(key, serializedState);
//   } catch (error) {
//     console.error("Set state error: ", error.message);
//   }
// };

// const load = key => {
//   try {
//     const serializedState = localStorage.getItem(key);
//     return serializedState === null ? undefined : JSON.parse(serializedState);
//   } catch (error) {
//     console.error("Get state error: ", error.message);
//   }
// };

// export default {
//   save,
//   load,
// };

// Теперь мы можем безопасно добавлять и читать записи из локального хранилище. Попробуйте самостоятельно дописать метод remove(key) для удаления записи, аналогично load(key) и save(key, value).